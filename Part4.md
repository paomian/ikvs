## 实现一个kv数据库-第四部分 API设计

@(翻译)[kvdb|MarkDown]

这是IKVS系列的第四部分，你也可以通过文章列表选择其他本系列的部分。

我终于为我的kv数据库项目选定了一个名字，从现在开始他叫FelixDB。

在本文中，我将要看看这四个kv数据库和数据库系统的api：LevelDB，Kyoto Cabinet，BerkekeyDB and SQLite3。对于它们的api的每个主要功能，我会对比命名方式和方法原型平衡利弊，并为我正在开发的kv数据库FelixDB设计一套api，本文将介绍：

1. API设计的一般原则。
2. 定义功能性的FelixDB的公共API
3. 比较现有数据库的API  
    3.1 打开和关闭数据库  
    3.2 读取和写入  
    3.3 迭代  
    3.4 参数化  
    3.5 错误管理  
4. 结论
5. 参考文献

**1. API设计的一般原则**

设计一个好的API是困难的，真的困难，但我不是要说什么的新的东西，只是复述我以前已经讲过的很多东西。迄今为止，我发现最佳的关于API设计的资源是Jonshua Bloch的格言式的报告“如何设计好的API和他为什么那么重要”。如果你还没有机会看这次报告，我强烈建议你花时间把他看完，在报告过程中，Bloch明确指出听众应该记得的两个重要的事情，我抄了报告的这些点，并增加了一些观点。
    1. 如果有疑问，抛弃他，如果不确定API中是否要包含一个功能，类，方法，参数，就不要包含他。
    2. 不要让客户端做任何库可以做的事，如果你的API让客户端执行了一系列上一个函数调用和插件的结果是下一个的输入，只需要在你的API中添加一个函数来做一系列的函数调用。
    针对良好的API设计的资源有在Scott Meyers写的`Effective C++`和Joshua Bloch写的`Effective Java`的第四章设计与声明。
    这些资源对现阶段的kv数据库项目是非常重要的，但我认为要考虑到不包含这些资源的一个重要的因素是很重要的：用户期望。从头设计一个api太鸡吧难了，kv数据库就不一样，有历史，设计api容易多了。用户一直在使用其他kv数据库和数据库系统的API，因此，当用户面对一个新的kv数据库的API是，它们期望这些是以前所熟悉的，而不是要增加学习曲线的去遵循不熟悉的API，而且这会使它们恼怒。
    出于这个原因，即使我知道上述我列出来所有资源中的好的意见，我也会考虑我将尽可能的复制现有库的API，我创建这样的API的优势是因为这将使用户更容易的使用它们。
    
**2. 为FelixDB公共API定义功能**
